using UnityEngine;

public class Camera_Control : MonoBehaviour
{
    [SerializeField] private Transform player;
    public Vector3 CameraPosition;

    // Start is called before the first frame update
    void Start()
    {

    }

    // Update is called once per frame
    void Update()
    {
        transform.position = new Vector3(player.position.x, player.position.y + CameraPosition.y, CameraPosition.z);
    }
}

using UnityEngine;
using UnityEngine.SceneManagement;

public class Finish : MonoBehaviour
{
    private AudioSource finishsound;
    private bool completelevel = false;

    void Start()
    {
        finishsound = GetComponent<AudioSource>();
    }

    private void OnTriggerEnter2D(Collider2D collision)
    //2D碰撞函数，参数为2D碰撞器
    {
        if(collision.gameObject.name == "Player" && !completelevel)
        //旗帜接触到玩家  并且  没有触发关卡结束
        {
            finishsound.Play();
            completelevel = true;
            Invoke("CompleteLevel",2f);
            //Invoke函数会在2.0秒后调用CompleteLevel函数
        }
    }

    private void CompleteLevel()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1 );
        //切换到下一个场景
    }
}

using UnityEngine;
using UnityEngine.UI;

public class ItemCollector : MonoBehaviour
{
    private int cherries = 0;
    [SerializeField] private Text CheeriesText;
    [SerializeField] private AudioSource collectsound;

    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.gameObject.CompareTag("cherry"))
        {
            Destroy(collision.gameObject);
            cherries ++;
            CheeriesText.text = "Cheereis:" + cherries;
            collectsound.Play();
            //碰撞到带有樱桃标签的对象时，销毁对象并使玩家获得的樱桃+1，播放拾取的音源
        }
    }
}

using UnityEngine;
using UnityEngine.SceneManagement;

public class Player_life : MonoBehaviour
{
    private Rigidbody2D rb;
    private Animator anim;
    [SerializeField] private AudioSource deathsound; 
    
    private void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        anim = GetComponent<Animator>();
    }

    private void OnCollisionEnter2D(Collision2D collision)
    {
        if (collision.gameObject.CompareTag("Trap"))//如果碰撞到trap图层的对象
        {
            rb.bodyType = RigidbodyType2D.Static;//切换玩家的身体类型为静态(不可移动与交互)
            anim.SetTrigger("death");//播放死亡动画
            deathsound.Play();
        }
    }
    private void restart()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);

    }
}

using UnityEngine;

public class PlayerMove : MonoBehaviour
{
  
    private Rigidbody2D rb;// 刚体
    private BoxCollider2D bc;//2D盒控制器
    private Animator Ani;//动画控制器
    private SpriteRenderer sprite;//精灵
    private enum MovementState {idle,running, jumping,falling}//创建一个数据结构，包含四个动画
    [SerializeField] private AudioSource jumpsound;//声音组件



    [SerializeField] private LayerMask lm;//显式声明，图层层级

    private Vector2 Movement; // 移动方向,二维变量
    public float MoveSpeed = 6f; // 移动速度
    public float jumpspeed = 24f;//跳跃速度

    public float PressingTime;//按住时间
    public KeyCode keyToCheck = KeyCode.Space;//要检测的按键
    public float Monitoring_;//速度检测
    
    void Start()
    {
        rb = GetComponent<Rigidbody2D>();
        bc = GetComponent<BoxCollider2D>();
        Ani = GetComponent<Animator>();
        sprite = GetComponent<SpriteRenderer>();
    }

    void Update()
    {
        ADMove(); //左右移动
        Anima();//动画
        Jump();//跳跃
        PressTimeCheck();
        Dodge();//闪避
        Monitoring_ = Movement.x;
    }


    void FixedUpdate()
    {

    }
    
    void ADMove()
    {
        
        Movement.x = Input.GetAxis("Horizontal"); // A/D 或 左/右键
        //GetAxis 和 GetaxisRaw:"前者能让移动的过渡更加平滑，属于给物体添加一个加速度，后者则是直接改变物体的速度，适用于角色的旋转"
        // movement = movement.normalized;//归一化，在2D平台游戏中是双向+跳跃，所以不需要
        rb.velocity = new Vector2(Movement.x * MoveSpeed, rb.velocity.y);//专注于X轴的移动
        //rb.velocity = movement * moveSpeed * Time.deltaTime;//别让代码做多余的事，这里的数据转移影响了跳跃
        //为什么不设置帧差？“虽然你固定了玩家每秒的移动距离，但移动过程会因为帧率波动导致速度不稳定”
        //“出于玩家游戏体验的考虑，我们需要更稳定的移动，而不是公平的移动速度”
    }

    private void Anima()
    {  
        MovementState state;
        if(Movement.x > 0f)
        {
            state = MovementState.running;
            sprite.flipX = false;
        }
        else if(Movement.x < 0f)
        {
            state = MovementState.running;
            sprite.flipX = true;
        }
        else 
        {
            state = MovementState.idle;
        }

        if (rb.velocity.y > .1f)//通过检查Y速度，判断是否处于下落或者跳跃上升
        {
            state = MovementState.jumping;
        }
        else if (rb.velocity.y < -.1f)
        {
            state = MovementState.falling;
        }
        Ani.SetInteger("state",(int)state);
        
    }

    void Jump()//按下空格键，给玩家一个瞬间向上的力
    {
        if (Input.GetKeyDown(KeyCode.Space) && IsGrounded())
        {
            GetComponent<Rigidbody2D>().velocity = new Vector2(0, jumpspeed);
            jumpsound.Play();
        }
    }

    void Dodge()
    {
        // if (Input.GetKeyDown(KeyCode.L))
        //     GetComponent<Rigidbody2D>().velocity = new Vector2(jumpspeed, 0);

    }

    void Attack()
    {

    }
    
    void PressTimeCheck()//按键时长检测
    {
           if (Input.GetKey(keyToCheck))
        {
            PressingTime += Time.deltaTime; // 获得按键按住时间
        }
        else if (Input.GetKeyUp(keyToCheck)) // 按键松开时
        {
            Debug.Log($"按键 {keyToCheck} 按住了 {PressingTime:F2} 秒");
            PressingTime = 0f; // 重置计时器
        }
    }

    private bool IsGrounded()
    {
        return Physics2D.BoxCast(bc.bounds.center, bc.bounds.size, 0f, Vector2.down, .1f,lm);
    }
}


 
using UnityEngine;

public class quit : MonoBehaviour
{
    public void Quit()
    {
        Application.Quit();
    }
}

using UnityEngine;

public class Rotate : MonoBehaviour
{
    [SerializeField] private float speed = 2f;
    void Update()
    {
        transform.Rotate(0,0,360 * speed * Time.deltaTime);//无需动画，通过脚本旋转锯片
    }
}

using UnityEngine;
using UnityEngine.SceneManagement;

public class StartGame : MonoBehaviour
{
    public void startgame()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);
    }
}

using UnityEngine;

public class StickyPhysic : MonoBehaviour
{
    void OnTriggerEnter2D(Collider2D collision)
    {
        if(collision.gameObject.name == "Player")
        {
            collision.gameObject.transform.SetParent(transform); 
            //当移动平台接触到玩家时，将平台设为玩家的父类来实现玩家与平台的一起移动
        }
    }

    void OnTriggerExit2D(Collider2D collision)
    {
        if(collision.gameObject.name == "Player")
        {
            collision.gameObject.transform.SetParent(null);
            //当移动平台不再接触到玩家时，将玩家的父类设为空来实现脱离接口
        }
    }
}

using UnityEngine;

public class WayPointFollower : MonoBehaviour
{
    [SerializeField] private GameObject[] waypoints;
    private int WayPointIndex = 0;
    [SerializeField] private float speed = 2f;
    private void Update()
    {
        if(Vector2.Distance(waypoints[WayPointIndex].transform.position,transform.position) < .01f)//判断：对象触碰到航路点
        {
            WayPointIndex++;
            if (WayPointIndex >= waypoints.Length)
            {
                WayPointIndex = 0;
            }
        }
        transform.position =Vector2.MoveTowards(transform.position,waypoints[WayPointIndex].transform.position,speed*Time.deltaTime);
        //使用帧差确保每秒移动的距离统一，不会因为不同的帧率导致每秒出现不同的移动距离，速度*统一每秒帧 = 相同的距离
    }
}
